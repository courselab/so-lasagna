Para a funcionalidade de listar os arquivos do sistema é preciso definir, além do header que está en forma de struct na posição 0x7c00, em que posição de memória estão os nomes dos arquivos. Isso é definido pela linha: 
#define DIR_BUFFER_ADDRESS  0x9000

O setor que contém os nomes dos arquivos está logo depois dos setores de boot, portanto ele é calculado como o número de setores de boot mais um:
int dir_start_sector = 1 + header->number_of_boot_sectors;

O número de bytes a serem lidos para retornar os nomes de todos os arquivos é o número de possíveis arquivos vezes o tamanho dos nomes, que é 32B: header->number_of_file_entries * 32
Como cada setor tem 512B, o número de setores é o número de bytes a serem lidos dividido por 512B:
int dir_sectors_to_read = header->number_of_file_entries * 32 / 512;

Cria-se um ponteiro apontando para uma região de memória em que serão carregados os dados:
extern byte _MEM_POOL;
void *dir_section_memory = (void *)&_MEM_POOL;

Criou-se uma função para carregar os setores do disco para a memória, considerando o setor inicial, quantos setores a serem lidos e a região da memória em que serão carregados os dados:
LerDisco(dir_start_sector, dir_sectors_to_read, dir_section_memory);

Antes de mexer com os registradores, salva-se os valores atuais. 
Seleciona-se o drive de boot, a operação de ler setor no serviço de disco da BIOS, carrega-se o número de setores a serem lidos, as coordenadas de cilindro, setor e cabeça, onde carregar os dados na memória.
Finalmente, chama o serviço de disco da BIOS através de int $0x13 e restaura-se os valores dos registradores.
void LerDisco(int sector_coordinate, int readSectors, void *target_address) {
    __asm__ volatile(
        "pusha \n"                    
        "mov boot_drive, %%dl \n"     
        "mov $0x2, %%ah \n"           
        "mov %[sectToRead], %%al \n"  
        "mov $0x0, %%ch \n"           
        "mov %[sectCoord], %%cl \n"   
        "mov $0x0, %%dh \n"           
        "mov %[targetAddr], %%bx \n"  
        "int $0x13 \n"                
#if 0
	"mov $error%=, %%cx \n"
	"jc fatal \n"
	"jmp end%=\n"
#endif	
        "popa \n"                     
#if 0
	"error%=: \n"
	" .string \"Read failed\\n\"  \n"
	"end%=:"
#endif
	
        ::
        [sectCoord] "g"(sector_coordinate),
        [sectToRead] "g"(readSectors),
        [targetAddr] "g"(target_address)
    );
}

Para ler os nomes dos arquivos, executamos um laço variando i de 0 ao número de possíveis arquivos, avançando na memória de 32 em 32B, e só imprimimos se o primeiro caracter não for vazio
for (int entry_index = 0; entry_index < header->number_of_file_entries; entry_index++) 
{
  char *entry_name = dir_section_memory + entry_index * 32;
  if (entry_name[0]) 
  {
    kwrite(entry_name);
    kwrite("\n");
  }
}

Para a funcionalidade de executar um arquivo no volume, executa-se um laço que percorre todos os nomes dos arquivos, como foi feito na funcionalidade de listar os nomes dos arquivos, com a finalidade de encontrar o nome do arquivo desejado. 

Ao encontrar o arquivo, calcula-se a coordenada do setor como o setor inicial (como foi calculado na funcionalidade anterior), mais o número de setores a serem lidos (como foi calculado na funcionalidade anterior), 
pois não iremos ler os nomes dos arquivos e sim o arquivo em si, mais i vezes o tamanho máximo de um arquivo, sendo que i é a posição do arquivo desejado dentre os arquivos do volume.

struct fs_header_t *fs_header = get_fs_header();

  int directory_sector_coordinate = 1 + fs_header->number_of_boot_sectors;
  int sectors_to_read = fs_header->number_of_file_entries * 32 / 512 + 1;

  int memoryOffset = fs_header->number_of_file_entries * 32 - (sectors_to_read - 1) * 512;

  extern byte _MEM_POOL;
  void *directory_section = (void *)&_MEM_POOL;
  
  LerDisco(directory_sector_coordinate, sectors_to_read, directory_section);

for (int i = 0; i < fs_header->number_of_file_entries; i++) {
    char *file_name = directory_section + i * 32;
    if (!strcmp(file_name, binary_file_name)) {
      bin_sector_coordinate = directory_sector_coordinate + sectors_to_read + fs_header->max_file_size * i - 1;
      break;
    }
  }
  if (bin_sector_coordinate == -1) {
    kwrite("Program not found.\n");
    return;
  }

Então, chamamos a função LerDisco, porém agora a coordenada do setor é a posição em que está o arquivo a ser lido, o número de setores a serem lidos é o tamanho máximo do arquivo (foi dado em número de setores no header), 
e o endereço de memória que receberá o arquivo é 0xFE00.
  int memoryOffset = fs_header->number_of_file_entries * 32 - (sectors_to_read - 1) * 512;
  void *program = (void *)(0xFE00);
  void *program_sector_start = program - memoryOffset;
  LerDisco(bin_sector_coordinate, fs_header->max_file_size, program_sector_start);

Com isso, para de fato executarmos o programa, salvamos os valores atuais dos registradores, salvamos o endereço de retorno (para quando finalizar o programa), pulamos para o endereço 0xFE00, que é onde foi carregado o programa.
Ao retornar do programa, restauramos os valores anteriores dos registradores.
exec_prog:
	pusha 
	pushl $exec_prog_end	/* Push return address. */
	jmp 0xfe00		/* Jump to program. */
exec_prog_end:
	popa
	ret

